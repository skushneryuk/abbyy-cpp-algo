## Задача 2. [Interleaving String](https://leetcode.com/problems/interleaving-string/)

Забьем немного на запутывающее условие и поймем, что от нас, на самом деле, требуется проверить, можно ли представить `s1` и `s2` как две непересекающиеся подпоследовательности `s3`, которые в совокупности и дают `s3`

Будем решать задачу методом динамического программирования. Исходя из этого получим и асимптотику

### Решение

Будем жить в 1...N - нотации

Пусть `dp[i][j]` - это результат проверки `interleaving(s1[:i], s2[:j], s3[:i+j])`. В частности, `dp[i][0]` - это проверка для нулевой второй строки, т.е проверка, что префиксы длины `i` у `s1` и `s3` совпадают. Аналогично `dp[0][j]`. Тогда `dp[len(s1)][len(s2)]` - ответ на задачу

Как можно пересчитать такую `dp`? На самом деле, для `dp[i][j]` нам достаточно знать лишь `dp[i-1][j]` и `dp[i][j-1]` (значения `dp[i][0]` и `dp[0][j]` считаем предподсчитанными за линию как простые проверки равенства суффиксов для всех возможных `i` и `j`). Пересчет таков

$$
\text{dp[i][j]} = \begin{cases}
    \mathrm{true}, \text{ если } dp[i-1][j] = \mathrm{true} \text{ и } s1[i] = s3[i+j] \\
    \mathrm{true}, \text{ если } dp[i][j-1] = \mathrm{true} \text{ и } s2[j] = s3[i+j] \\
    \mathrm{false}, \text{ иначе}
\end{cases}
$$

Почему это так. Ну, действительно, можно раскрутить рекурсию, что если `dp[len(s1)][len(s2)] = true`, то какой-то из последних символов `s1` или `s2` совпал с последним символом `s3` (Б.О.О, `s1`), а значит обязательно `interleaving(s1[:len(s1)-1], s2, s3[:len(s3)-1]) = true`. Мы же делаем это не рекурсивно, а за $O(len(s1) \cdot len(s2))$, ведь ровно столько нам операций и нужно, чтобы обсчитать всю матрицу `dp`

В простом решении потребовалось бы также $O(len(s1) \cdot len(s2))$, памяти, но я представил улучшенное и достаточно стандартное решение, где `dp[i][j]` обсчитывается строка за строкой и поэтому расходы по памяти сократились до $O(len(s2))$, а вообще, если постараться, то можно сократить до $O(min(len(s1), len(s2)))$, если заморочиться и выбирать, высчитывать `dp[i][j]` по строке или по столбцу