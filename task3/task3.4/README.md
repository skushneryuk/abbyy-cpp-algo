## Задача 4. [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)

Я предоставил 2 решение. [Второе](./solution_fast.cpp) является переработанным, переосмысленным и улучшенным с точки зрения асимптотики [первым](./solution.cpp).

Идея:

Преградой назовем такой элемент в массиве, что либо слева, либо справа от него нет ни одного элемента больше него. Пусть все преграды будут `barrier[i]`. Можно заметить, что на преградах вода не "застревает", т.к. для этого нужно было, чтобы и слева, и справа были 2 места с высотой больше, но это противоречит определению преграды

Рассмотрим какой-то место на карте высот (не преграду) c индексом `k`. Пусть слева и справа ближе всего к нему находятся `barrier[i]` и `barrier[i+1]`, и БОО `barrier[i] < barrier[i+1]`. Тогда в этом месте вода будет находится на высоте `barrier[i]`: высота воды не может быть меньше, потому что ей некуда утекать, и не может быть выше, т.к. тогда слева есть еще высота, ограничивающая отток воды и больше чем `barrier[i]`. Но этой высоты не может быть левее `barrier[i]`, т.к. это противоречит определению преграды `barrier[i]`. Ее не может и быть между `barrier[i]` и элементом `k`, т.к. тогда обязательно это была бы преграда и это противоречило бы выбору ближайшей слева преграды

Таким образом мы по определению местоположения всех преград на карте можем определить высоту воды в каждой точке. А зная высоту воды и высоту этого места до дождя можно понять, какой вклад дает в общий объем воды именно это место

### Решение 1
Заметим, что максимум во всем массиве - это преграда

Заметим еще, что высоты преград сначала растут к максимуму, а потом от него убывают. На этом и основано первое решение: находим максимум, а потом от него находим все преграды слева и справа от максимума

Это делается с помощью стека: идем по порядку от максимума влево или вправо и кладем на стек все элементы по порядку, а когда пытаемся положить новый элемент, убираем со стека все элементы меньше данного. Таким образом на стеке будет лежать убывающая последовательность преград. Запомнив, где они изначально стояли, можно расчитать высоту воды на всей карте и получить ответ

Поиск максимума + проход по всему массиву + рассчет высоты по двум соседним преградам (пользуясь фактом про монотонность высот преград справа и слева от максимума) - это все $O(N)$ времени и столько же памяти

### Решение 2
Нам по сути в каждом месте карты `k` нужно знать минимум из высот двух соседних преград `barrier[i]` и `barrier[i+1]`. Если БОО мы находимся слева от максимума, то это всегда левая преграда `barrier[i]`. При этом, т.к. это преграда, то исходя из определения она еще и максимум на левом префиксе `height[:k]`. Аналогично и для ситуации справа от максимума

Таким образом можно забить, по сути, на поиск именно преград и считать для каждого элемента максимумы на левом и правом префиксах, ведь взяв минимум из этих максимумов мы и получим значение высоты минимальной из соседних преград

Рассчет кумулятивно максимума на префиксе и на суффиксе + еще проход для рассчета ответа - это вновь $O(N)$ времени и столько же памяти, но с меньшей константой
