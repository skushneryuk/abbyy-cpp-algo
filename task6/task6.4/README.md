## Задача 4. [Critical Connections in a Network](https://leetcode.com/problems/critical-connections-in-a-network/)

Применим алгоритм поиска мостов

Идея такова: запустим DFS от какой-то из вершин и рассмотрим дерево обхода. Теперь, если рассмотреть все ребра исходного графа, то можно  отметить следующее: в дереве обхода нет "горизонтальных" связей, т.е. ребро может пойти либо в предка, либо куда-то вниз в потомков, потому что если бы такое ребро было, то это значило, что во время DFS мы это ребро пропустили и не пошли по нему в потомка

Также введем порядок обхода и будем хранить момент времени $t_{in}$, когда мы вошли в вершину. Эта величина, очевидно, увеличивается во время обхода. Теперь можно сказать про мосты следующее: это такие ребра $(u, v)$ (будем считать БОО, что $t_{in}[u] < t_{in}[v]$), что у потомков $v$ нет связей "наверх", т.е. нет ребер в вершины, которые были рассмотрены раньше, чем $u$ (в т.ч. и саму $u$)

Тогда, если хранить в $f_{up}[v]$ значение минимального значения $t_{in}$ для вершин, в которые можно добраться из $v$ (т.е. потомки $v$ и, возможно, просмотренные ранее во время обхода вершины, инцидентные потомкам $v$), то это и будет учитывать все возможные походы "наверх" к уже просмотренным вершинам. При этом можно показать (более подробно с огромным доказательством этого факта [здесь](https://neerc.ifmo.ru/wiki/index.php?title=Использование_обхода_в_глубину_для_поиска_мостов) и [здесь](https://e-maxx.ru/algo/bridge_searching)), что в частности это значит, что $(u, v)$ - мост, если $t_{in}[u] < f_{up}[v]$

Т.е. теперь осталось лишь реализовать подсчет этих величин (их можно делать прямо во время DFS) и по указанному критерию определять мосты. Асимптотика будет как у обычного DFS