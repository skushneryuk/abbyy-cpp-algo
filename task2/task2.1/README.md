## Задача 1. [Permutations II](https://leetcode.com/problems/permutations-ii/)

> Time Complexity $\mathbb{O}(N! * N + N \log N)$ - основной алгоритм + предварительная сортировка

> Memory Usage:
> - $\mathbb{O}(N! * N)$ на ответ
> - $\mathbb{O}(N)$ для промежуточных вычислений в процессе (в т.ч. сортировка)

Алгоритм следующий:
1. Начнем с лексикографически первой перестановки, а именно всеми числами по возрастанию
2. Будем получать лексикографически следующую перестановку
3. Остановимся, когда получим лексикографически наибольшую перестановку, т.е. все числа по убыванию

Так как всего перестановок не более $N!$, а получение лексикографически следующей перестановки можно выполнить за $\mathbb{O}(N)$ (дальше объясню как), то получаем итоговую асимптотику

Немного схитрим и воспользуемся здесь функцией next_permutation, но объясним, как она работает:

------

### Утв. 1: A - лексикографически наименьшая перестановка множества S. Тогда A = ascending_sort(A)

> **Доказательство**: от противного, пусть это не так, значит найдется другая наименьшая перестановка B. Пусть $k$ - такой индекс, что A[:k] == B[:k], но A[k] != B[k]

> - С одной стороны A[k] $\leq$ B[k], т.к. A[k] = min(B[k:]), ибо A отсортировно по возрастанию

> - С другой стороны A[k] $\gt$ B[k], т.к. B лексикографически меньше и k - последний индекс, на котором эти перестановки совпадают. Получили противоречие

-----
### Утв. 2: A - лексикографически наибольшая перестановка множества S. Тогда A =  descending_sort(A)

> **Доказательство**: абсолютно аналогично с точностью до замены всех знаков на обратные

-----
### Лемма 1: Можно построить алгоритм получения следующей перестановки next(A) за $O(N)$

> **Доказательство**: (случай с A - максимальной перестановкой отметаем сразу и считаем, что $A < next(A)$) Поймем, как именно выглядит следующая перестановка. Для этого найдем общий префикс A и next(A). 

> **Утверждение**: Пусть $A[:k] = next(A)[:k]$. Тогда $A[k] != next(A)[k]$. Заметим, что A[k+1:] упорядочен по убыванию

> Действительно, если это неверно, то тогда упорядочив этот хвост по убыванию можно было бы получить лексикографически большую перестановку не трогая при этом элемент A[k], т.е. было бы $A[k] = next(A)[k]$, но это противоречит нашему выбору next(A) и $k$

> **Утверждение**: next(A)[k] - самый маленький из элементов A[k+1:], который больше, чем A[k]

> Действительно, next(A)[k] обязан быть больше, чем A[k], иначе нарушается условие на порядок между перестановками. Кроме того, он не может быть слишком большим, иначе можно было бы взять какой-то элемент между A[k] и next(A)[k] и получить большую лексикографически перестановку, чем A.

> **Утверждение**: next(A)[k+1:] упорядочен по возрастанию

> Действительно, ведь благодаря тому, что по условию $A[k] < next(A)[k]$, то и $A < next(A)$. Но если next(A)[k+1:] не упорядочен по возрастанию, то можно упорядочить, все еще получить перестановку большую чем A, но меньшую чем next(A)

> Из всего этого получаем алгоритм:

> 1. Находим наибольший убывающий суффикс A - A[k+1:]. На A[k] упорядоченность ломается. Это поиск работает за $O(N)$

> 2. Находим в этом суффиксе A[k+1:] первый элемент A[j], j > k, меньший A[k] и меняем их местами. При этом суффикс A'[k+1:] все еще убывает по условию, т.к. $\forall i: k < i \le j \implies A[j] > A[k]$ и $\forall i: i \gt j \implies A[j] < A[k]$ по условию замены. Этот поиск тоже работает за $O(N)$

> 3. Разворачиваем хвост A'[k+1:], тем самым получая next(A). Разворот последовательности тоже работает за $O(N)$

Все операции не требуют дополнительной памяти более константы.

Тем самым доказали асимптотику всего решения