## Задача 8. [Redundant Connection II ](https://leetcode.com/problems/redundant-connection-ii/)

Рассмотрим исходное дерево и лишнее ориентированное ребро $(u, v)$. Отметим, что в любом случае, если рассматривать граф как неориентированный, то у нас получается унициклические граф, в котором всегда можно удалить любое ребро из цикла, но с точки зрения ориентированного графа могут получаться различные случаи. Рассмотрим их:

1. $u$ - предок $v$ (родитель или родитель родителя или ...). В таком случае, удалив любое из двух ребер, ведущих в $v$ мы не потеряем связности всего графа из корня - до $v$ все еще можно будет добраться, как и до его детей, т.к. еще один из двух путей до $v$ будет существовать, до оставшихся детей $u$, которые не являются детьми $v$, можно добраться как и раньше, как и до всех остальных вершин не из поддерева $u$

2. $v$ - предок $u$ и $v \neq root$. Т.е. у нас возникает цикл и картинка вида "лассо", если смотреть на путь $root \rightarrow v \rightarrow u \rightarrow v$. В таком случае, мы не можем удалить никакое другое ребро, кроме как само ребро $(u, v)$, потому что иначе исчезнет путь $u$, потому что путь до $u$ из $root$ - единственный без учета цикла

3. $v$ - предок $u$ и $v = root$. Тогда любая из вершин на цикле может выступать в роли нового корня, а значит, можно удалить любое ребро на цикле

4. У $v$ и $u$ нет связи "предок-потомок", т.е. ребро $(u, v)$ связывавает 2 непересекающихся поддерева. Тогда вновь можно удалить любое из ребер, которые ведут в $v$ по тем же причинам, что и в случае 1

#### Реализация

1. Проходом по вершинам ищем вершину $x$, у которой 2 предка. Если такой нет (т.е. где-то есть цикл из случа 3), то указываем вершину как $x = -1$. И вообще для каждой вершины сохраняем их предка (предков для $x$)

2. "Обстригаем" дерево, т.е. удаляем все висячие вершины (т.е. без с исходящей степенью 0), чтобы обнаружить один из кейсов, описанных выше. Это можно сделать с помощью очереди, т.к. каждый раз, удаляя висячую вершину a, их множество может пополниться лишь предком a
   
    1. По пути, если вдруг обнаружим, что $x$ стало висячей вершиной. значит это либо случай 1, либо случай 4 и тогда можно вернуть одно из ребер, ведущих в $x$

3. На этом этапе пытаемся понять, что у нас за случай остался:

    1. Если $x = -1$, то после обрезания деревьев остался цикл и можно удалить любое ребро
    2. Если $x \neq -1$, то ищем то самое ребро, которое вновь входит в "лассо". Найти его можно, запустившись из $x$ по предкам назад начиная с одного из двух предков $x$ (т.е. по первому из двух ведущих в $x$ ребер). Если в какой-то момент окажется, что мы вновь встретили $x$, то удаляем то самое первое ребро, ведущее в $x$. Иначе, если мы дошли до корня, то нужно удалить второе из ребер, ведущих в $x$

Таким образом мы рассмотрим все случаи

P.S. выше выбор произвольного ребра из нескольких вариантов, очевидно, не учитывал условие задачи на удаление последнего из возможных ребер. В реализации это учтено